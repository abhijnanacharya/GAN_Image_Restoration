import os
import torchvision.transforms.functional as TF
import torch
from torchvision.utils import save_image

def save_generated_images(lr_images, generated_images, hr_images, sample_dir, epoch, batch_idx):
    """
    Save a grid of low-resolution, generated, and high-resolution images.
    Args:
        lr_images: Low-resolution input images.
        generated_images: Images generated by the generator.
        hr_images: High-resolution ground truth images.
        sample_dir: Directory where the images will be saved.
        epoch: Current epoch number.
        batch_idx: Current batch index.
    """
    # Ensure sample directory exists
    os.makedirs(sample_dir, exist_ok=True)
    
    # Concatenate low-res, generated, and high-res images for comparison
    images = torch.cat([lr_images[:4], generated_images[:4], hr_images[:4]], dim=0)
    
    # Define the save path
    save_path = os.path.join(sample_dir, f"epoch_{epoch}_batch_{batch_idx}.png")
    
    # Save the image grid
    save_image(images, save_path, nrow=4, normalize=True)
    print(f"Saved sample images to: {save_path}")
    
def degrade_image(image, degradation_type="both"):
    """
    Apply degradation (blur, noise, or both) to an image.
    Args:
        image: Input high-resolution image (PyTorch tensor).
        degradation_type: Type of degradation ('blur', 'noise', or 'both').
    Returns:
        Degraded image (PyTorch tensor).
    """
    if degradation_type == "blur":
        return TF.gaussian_blur(image, kernel_size=[7, 7], sigma=3.0)
    elif degradation_type == "noise":
        noise = torch.randn_like(image) * 0.1
        return torch.clamp(image + noise, -1, 1)
    elif degradation_type == "both":
        blurred = TF.gaussian_blur(image, kernel_size=[7, 7], sigma=3.0)
        noise = torch.randn_like(blurred) * 0.1
        return torch.clamp(blurred + noise, -1, 1)
    else:
        raise ValueError(f"Invalid degradation type: {degradation_type}")